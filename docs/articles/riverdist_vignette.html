<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>River Network Distance Computation and Applications with <code>riverdist</code> • riverdist</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">riverdist</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="..//index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/riverdist_vignette.html">River Network Distance Computation and Applications with `riverdist`</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>River Network Distance Computation and Applications with <code>riverdist</code>
</h1>
            
          </div>

    
    
<div class="contents">
<p><a href="#Package%20overview">Package overview</a></p>
<p><a href="#Typical%20workflow">Typical workflow</a></p>
<p><a href="#Limitations,%20notes,%20and%20caveats">Limitations, notes, and caveats</a></p>
<p><a href="#Importing%20and%20displaying%20river%20network%20data">Importing and displaying river network data</a></p>
<p><a href="#Basic%20distance%20calculation%20in%20a%20non-messy%20river%20network">Basic distance calculation in a non-messy river network</a></p>
<p><a href="#Incorporating%20flow%20direction">Incorporating flow direction</a></p>
<p><a href="#Allowing%20different%20route-detection%20algorithms%20a%20possible%20time-saver">Allowing different route-detection algorithms: a possible time-saver</a></p>
<p><a href="#Beyond%20individuals%20summarizing%20or%20plotting%20at%20the%20dataset%20level">Beyond individuals: summarizing or plotting at the dataset level</a></p>
<p><a href="#Editing%20a%20river%20network%20object,%20or%20fixing%20a%20messy%20one">Editing a river network object, or fixing a messy one</a></p>
<p><a href="#Dealing%20with%20braided%20channels">Dealing with braided channels</a></p>
<p><a name="Package%20overview"></a></p>
<div id="package-overview" class="section level2">
<h2 class="hasAnchor">
<a href="#package-overview" class="anchor"></a>Package overview</h2>
<p>The ‘riverdist’ package is intended as a free and readily-available resource for distance calculation along a river network. This package was written with fisheries research in mind, but could be applied to other fields. The ‘riverdist’ package builds upon the functionality of the ‘sp’ and ‘rgdal’ packages, which provide the utility of reading GIS shapefiles into the R environment. What ‘riverdist’ adds is the ability to treat a linear feature as a connected network, and to calculate travel routes and travel distances along that network.</p>
<p><a name="Typical%20workflow"></a></p>
</div>
<div id="typical-workflow-with-riverdist" class="section level2">
<h2 class="hasAnchor">
<a href="#typical-workflow-with-riverdist" class="anchor"></a>Typical workflow with ‘riverdist’</h2>
<ol style="list-style-type: decimal">
<li><p>Import a linear shapefile using <code><a href="../reference/line2network.html">line2network()</a></code>. The shapefile to import must be a linear feature - converting a polygon feature to a line feature will result in an outline, which will not be useable. The shapefile to import should be as simple as possible. If GIS software is available, both trimming the shapefile to the same region as the study area and performing a spatial dissolve are recommended.</p></li>
<li><p>Clean up the imported shapefile however necessary. Editing functions are provided, but the <code><a href="../reference/cleanup.html">cleanup()</a></code> function interactively steps through all the editing functions in a good order, and is recommended in nearly all cases.</p></li>
<li><p>Convert point data to river locations using <code><a href="../reference/xy2segvert.html">xy2segvert()</a></code> or <code>ptshp2segvert()</code>. This will snap each point to the nearest river network location.</p></li>
<li><p>Perform all desired analyses.</p></li>
</ol>
<p><a name="Limitations,%20notes,%20and%20caveats"></a></p>
</div>
<div id="limitations-notes-and-caveats" class="section level2">
<h2 class="hasAnchor">
<a href="#limitations-notes-and-caveats" class="anchor"></a>Limitations, notes, and caveats</h2>
<p>Care must be exercised in the presence of braided channels, in which multiple routes may exist between river locations. In these cases, the default route calculation provided by ‘riverdist’ will be the shortest travel route, but it is possible that the shortest travel route may not be the route of interest. Functions are provided to check for braiding, as well as select the route of interest. If no braiding is detected, route and distance calculation can switch to a more efficient algorithm.</p>
<p>Another important note is that only projected data can be used, both for river networks and for point data. The ‘riverdist’ environment in R does not share the ability of GIS software to project-on-the-fly, and treats all coordinates on a linear (rectangular) scale. Therefore, the projection of all data must also be the same.</p>
<p><a name="Importing%20and%20displaying%20river%20network%20data"></a></p>
</div>
<div id="importing-and-displaying-river-network-data" class="section level2">
<h2 class="hasAnchor">
<a href="#importing-and-displaying-river-network-data" class="anchor"></a>Importing and displaying river network data</h2>
<p><a href="#Importing%20a%20river%20network">Importing a river network</a></p>
<p><a href="#Displaying%20a%20river%20network">Displaying a river network</a></p>
<p><a href="#Checking%20connectedness">Checking connectedness</a></p>
<p><a href="#Converting%20XY%20data%20to%20river%20locations">Converting XY data to river locations</a></p>
<p><a href="#Displaying%20point%20data%20in%20river%20locations">Displaying point data in river locations</a></p>
<p><a name="Importing%20a%20river%20network"></a></p>
<p><strong>Importing a river network using <code><a href="../reference/line2network.html">line2network()</a></code></strong></p>
<p>In a typical workflow, a user will first import a projected polyline shapefile using <code><a href="../reference/line2network.html">line2network()</a></code>. This function reads the specified shapefile using the ‘sp’ and ‘rgdal’ packages, and adds the network connectivity, thus creating a river network object. If an unprojected shapefile is detected, an error will be generated. However, the <code>reproject=</code> argument allows the <code><a href="../reference/line2network.html">line2network()</a></code> to re-project the shapefile before importing it as a river network.</p>
<p>While ‘riverdist’ does provide tools for editing a river network that do not rely on GIS software, it is strongly recommended to simplify the river shapefile as much as possible before importing into R. In particular, a spatial dissolve will likely be very helpful, if GIS software is available. This will create a few long line segments instead of many, many short segments.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(riverdist)
MyRivernetwork &lt;-<span class="st"> </span><span class="kw"><a href="../reference/line2network.html">line2network</a></span>(<span class="dt">path=</span><span class="st">"."</span>, <span class="dt">layer=</span><span class="st">"MyShapefile"</span>)

<span class="co"># Re-projecting in Alaska Albers Equal Area projection:</span>
AKalbers &lt;-<span class="st"> "+proj=aea +lat_1=55 +lat_2=65 +lat_0=50 +lon_0=-154</span>
<span class="st">    +x_0=0 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"</span>

MyRivernetwork &lt;-<span class="st"> </span><span class="kw"><a href="../reference/line2network.html">line2network</a></span>(<span class="dt">path=</span><span class="st">"."</span>, <span class="dt">layer=</span><span class="st">"MyShapefile"</span>, <span class="dt">reproject=</span>AKalbers)</code></pre></div>
<p><a name="Displaying%20a%20river%20network"></a></p>
<p><strong>Displaying a river network using <code>plot()</code></strong></p>
<p>Basic plotting is provided using a method of the <code>plot()</code> function. See <code>help(plot.rivernetwork)</code> for additonal plotting arguments and graphical parameters. Shown below is the Gulkana River network, included as a dataset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(riverdist)
<span class="kw">data</span>(Gulk)
<span class="kw">plot</span>(<span class="dt">x=</span>Gulk)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-2-1.png" width="480"></p>
<p>Once the river network has been imported, some cleanup may be necessary, depending on the structure of the shapefile. Ideally, there should be one segment between each endpoint or junction node, and the spatial extent of the shapefile should be limited to the region or network of interest. If the user has GIS software available, it may be simplest to format the shapefile as desired before importing into R. However, functions are included for river network formatting in R if necessary. The <code><a href="../reference/cleanup.html">cleanup()</a></code> function interactively steps through the formatting functions in a good sequence, and may be a good way to get started. If there were spatial oddities with the parent shapefile (vertices out of order, or strange “jumps” in segments), the <code><a href="../reference/cleanup_verts.html">cleanup_verts()</a></code> function interactively steps through each individual segment, providing a means to edit the vertices of each segment if needed.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">abstreams_fixed &lt;-<span class="st"> </span><span class="kw"><a href="../reference/cleanup.html">cleanup</a></span>(abstreams0)</code></pre></div>
<p><a name="Checking%20connectedness"></a></p>
<p><strong>Checking connectedness using <code><a href="../reference/topologydots.html">topologydots()</a></code></strong></p>
<p>For route and distance calculation to work, the topologies must be correct, with all the right segments being treated as connected. The <code><a href="../reference/topologydots.html">topologydots()</a></code> function can check for this, and plots connected segment endpoints as green, and non-connected endpoints as red. This is shown below, and all appears good.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/topologydots.html">topologydots</a></span>(<span class="dt">rivers=</span>Gulk)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-4-1.png" width="480"></p>
<p><a name="Converting%20XY%20data%20to%20river%20locations"></a></p>
<p><strong>Converting XY data to river locations using <code><a href="../reference/xy2segvert.html">xy2segvert()</a></code> and <code><a href="../reference/pointshp2segvert.html">pointshp2segvert()</a></code></strong></p>
<p>Once an appropriate river network has been obtained, point data can be read. Function <code><a href="../reference/xy2segvert.html">xy2segvert()</a></code> converts XY data into river locations, by “snapping” each point to the closest segment and vertex. Because of this, river locations can only be used in the context of the river network they belong to. In addition to the river locations, the snapping distance for each observation is also returned.</p>
<p>The <code>fakefish</code> dataset includes coordinates from a sequence of telemetry flights.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(fakefish)
fakefish_riv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/xy2segvert.html">xy2segvert</a></span>(<span class="dt">x=</span>fakefish<span class="op">$</span>x, <span class="dt">y=</span>fakefish<span class="op">$</span>y, <span class="dt">rivers=</span>Gulk)
<span class="kw">head</span>(fakefish_riv)  <span class="co"># a look at the first few rows of the output</span></code></pre></div>
<pre><code>##   seg vert  snapdist
## 1   1  595 329.34419
## 2   1  399  40.27721
## 3   1  352 402.52259
## 4   1  116 525.06623
## 5   1  806 355.32753
## 6   1  505  11.34949</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">hist</span>(fakefish_riv<span class="op">$</span>snapdist, <span class="dt">main=</span><span class="st">"snapping distance (m)"</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-5-1.png" width="480"></p>
<p>Spatial data can be read directly from a point shapefile using <code><a href="../reference/pointshp2segvert.html">pointshp2segvert()</a></code>, which returns the resulting river locations added to the data table from the point shapefile.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">segvert_from_shp &lt;-<span class="st"> </span><span class="kw"><a href="../reference/pointshp2segvert.html">pointshp2segvert</a></span>(<span class="dt">path=</span><span class="st">"."</span>, <span class="dt">layer=</span><span class="st">"MyPointShapefile"</span>, 
                                     <span class="dt">rivers=</span>MyRivernetwork)</code></pre></div>
<p><a name="Displaying%20point%20data%20in%20river%20locations"></a></p>
<p><strong>Displaying point data in river locations using <code><a href="../reference/riverpoints.html">riverpoints()</a></code></strong></p>
<p>The <code><a href="../reference/riverpoints.html">riverpoints()</a></code> function works essentially like <code>points()</code> to overlay point data on an existing plot, but using river locations (segment and vertex). The <code><a href="../reference/zoomtoseg.html">zoomtoseg()</a></code> function produces a plot zoomed to the specified segment number, or vector of segment numbers.</p>
<p>In the plot below, the raw coordinates are displayed as red circles and the river locations are displayed as blue squares.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/zoomtoseg.html">zoomtoseg</a></span>(<span class="dt">seg=</span><span class="kw">c</span>(<span class="dv">11</span>, <span class="dv">14</span>), <span class="dt">rivers=</span>Gulk)
<span class="kw">points</span>(fakefish<span class="op">$</span>x, fakefish<span class="op">$</span>y, <span class="dt">pch=</span><span class="dv">16</span>, <span class="dt">col=</span><span class="st">"red"</span>)
<span class="kw"><a href="../reference/riverpoints.html">riverpoints</a></span>(<span class="dt">seg=</span>fakefish_riv<span class="op">$</span>seg, <span class="dt">vert=</span>fakefish_riv<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk, <span class="dt">pch=</span><span class="dv">15</span>, 
            <span class="dt">col=</span><span class="st">"blue"</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-7-1.png" width="480"></p>
<p><a name="Basic%20distance%20calculation%20in%20a%20non-messy%20river%20network"></a></p>
</div>
<div id="basic-distance-calculation-in-a-non-messy-river-network" class="section level2">
<h2 class="hasAnchor">
<a href="#basic-distance-calculation-in-a-non-messy-river-network" class="anchor"></a>Basic distance calculation in a non-messy river network</h2>
<p><a href="#Computing%20network%20distance">Computing network distance</a></p>
<p><a href="#Computing%20network%20distances%20between%20sequential%20observations%20of%20individuals">Computing network distances between sequential observations of individuals</a></p>
<p><a href="#Computing%20a%20matrix%20of%20network%20distances%20between%20all%20observations%20of%20an%20individual">Computing a matrix of network distances between all observations of an individual</a></p>
<p><a href="#Computing%20minimum%20observed%20home%20range%20for%20individuals">Computing minimum observed home range for individuals</a></p>
<p><a href="#Computing%20a%20matrix%20of%20network%20distances%20between%20all%20observations">Computing a matrix of network distances between all observations</a></p>
<p><a href="#Computing%20a%20matrix%20of%20network%20distances%20between%20all%20observations%20of%20two%20different%20datasets">Computing a matrix of network distances between all observations of two different datasets</a></p>
<p><a name="Computing%20network%20distance"></a></p>
<p><strong>Computing network distance using <code><a href="../reference/riverdistance.html">riverdistance()</a></code></strong></p>
<p>River network distance can be calculated directly with the <code><a href="../reference/riverdistance.html">riverdistance()</a></code> function. The <code><a href="../reference/riverdistance.html">riverdistance()</a></code> function calls <code><a href="../reference/detectroute.html">detectroute()</a></code> internally, which the user will probably never need, but usage is shown below. The <code><a href="../reference/riverdistance.html">riverdistance()</a></code> function needs river locations (segment and vertex) for both starting and ending locations. Specifying <code>map=TRUE</code> as shown below is not necessary, but can provide a check to verify that the function is working properly.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># starting location: segment 7, vertex 49</span>
<span class="co"># ending location: segment 14, vertex 121</span>
<span class="kw"><a href="../reference/detectroute.html">detectroute</a></span>(<span class="dt">start=</span><span class="dv">7</span>, <span class="dt">end=</span><span class="dv">14</span>, <span class="dt">rivers=</span>Gulk)</code></pre></div>
<pre><code>## [1]  7  6  3  4 10 11 14</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/riverdistance.html">riverdistance</a></span>(<span class="dt">startseg=</span><span class="dv">7</span>, <span class="dt">startvert=</span><span class="dv">49</span>, <span class="dt">endseg=</span><span class="dv">14</span>, <span class="dt">endvert=</span><span class="dv">121</span>, <span class="dt">rivers=</span>Gulk, <span class="dt">map=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-8-1.png" width="480"></p>
<pre><code>## [1] 155435.2</code></pre>
<p><a name="Computing%20network%20distances%20between%20sequential%20observations%20of%20individuals"></a></p>
<p><strong>Computing network distances between sequential observations of individuals using <code><a href="../reference/riverdistanceseq.html">riverdistanceseq()</a></code></strong></p>
<p>River distance can be calculated manually between any two connected locations on a river network. However, a few common summary analyses were automated and are included in ‘riverdist’. First, the <code><a href="../reference/riverdistanceseq.html">riverdistanceseq()</a></code> function returns a matrix of the distances between sequential observations for a set of individuals observed multiple times. In the example below, three fish were observed (or not) during 5 telemetry flights. The dataset is shown first, then the output from <code><a href="../reference/riverdistanceseq.html">riverdistanceseq()</a></code>. Fish number 1 traveled 83.87 km between flights 3 and 4, and was not observed during flight 2.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(smallset)
smallset</code></pre></div>
<pre><code>##    seg vert id flight
## 1   10   12  1      1
## 2    2   17  1      3
## 3   10   15  1      4
## 4    1  641  1      5
## 5    6  258  2      1
## 6   11  393  2      2
## 7    2   26  2      3
## 8    9  354  2      4
## 9    4  472  2      5
## 10   2   25  3      1
## 11   9  137  3      2
## 12   9  181  3      4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/riverdistanceseq.html">riverdistanceseq</a></span>(<span class="dt">unique=</span>smallset<span class="op">$</span>id, <span class="dt">survey=</span>smallset<span class="op">$</span>flight, <span class="dt">seg=</span>smallset<span class="op">$</span>seg, 
                   <span class="dt">vert=</span>smallset<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk)</code></pre></div>
<pre><code>##      1 to 2   2 to 3   3 to 4   4 to 5
## 1        NA       NA 83872.62 70277.57
## 2 127558.14 109561.1 94177.71 26741.99
## 3  86983.02       NA       NA       NA</code></pre>
<p><a name="Computing%20a%20matrix%20of%20network%20distances%20between%20all%20observations%20of%20an%20individual"></a></p>
<p><strong>Computing a matrix of network distances between all observations of an individual using <code><a href="../reference/riverdistancematbysurvey.html">riverdistancematbysurvey()</a></code></strong></p>
<p>River distance can also be calculated between all observations of a single individual. In the output matrix shown below for individual 1, the element with row identifier <code>1</code> and column identifier <code>3</code> represents the river distance from the location observed in survey 1 to the location observed in survey 3, calculated as 83.6 km. An important note is that the distances reported are net distance between locations, and are not intended to be cumulative. Specifying <code>full=TRUE</code> reports an output matrix that includes all observations, with values of <code>NA</code> if the individual was not observed. This allows the output matrices for multiple individuals to have the same rows and columns, thus being directly comparable.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/riverdistancematbysurvey.html">riverdistancematbysurvey</a></span>(<span class="dt">indiv=</span><span class="dv">1</span>, <span class="dt">unique=</span>smallset<span class="op">$</span>id, <span class="dt">survey=</span>smallset<span class="op">$</span>flight,
      <span class="dt">seg=</span>smallset<span class="op">$</span>seg, <span class="dt">vert=</span>smallset<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk, <span class="dt">full=</span><span class="ot">FALSE</span>)</code></pre></div>
<pre><code>##            1        3          4        5
## 1     0.0000 83588.99   283.6307 69993.94
## 3 83588.9911     0.00 83872.6219 45678.35
## 4   283.6307 83872.62     0.0000 70277.57
## 5 69993.9398 45678.35 70277.5705     0.00</code></pre>
<p><a name="Computing%20minimum%20observed%20home%20range%20for%20individuals"></a></p>
<p><strong>Computing minimum observed home range for individuals using <code><a href="../reference/homerange.html">homerange()</a></code></strong></p>
<p>The minimum observed (linear) home range for each individual can be calculated using <code><a href="../reference/homerange.html">homerange()</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># calculating observed minimum home range for all individuals</span>
<span class="kw"><a href="../reference/homerange.html">homerange</a></span>(<span class="dt">unique=</span>smallset<span class="op">$</span>id, <span class="dt">seg=</span>smallset<span class="op">$</span>seg, <span class="dt">vert=</span>smallset<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk)</code></pre></div>
<pre><code>## Minumum home ranges associated with each individual 
##  
##   ID     range
## 1  1  99914.27
## 2  2 141136.24
## 3  3  88669.52</code></pre>
<p>Maps can be produced by calling <code>plot()</code> on an object returned from <code><a href="../reference/homerange.html">homerange()</a></code>. Specifying <code>cumulative=TRUE</code> will create plots with line thickness varying by the number of times an individual would have traveled a given section of river. For a cumulative plot, either a vector of survey identifiers must be used, or else the data locations must be in chronological order for each individual.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))
ranges &lt;-<span class="st"> </span><span class="kw"><a href="../reference/homerange.html">homerange</a></span>(<span class="dt">unique=</span>smallset<span class="op">$</span>id, <span class="dt">survey=</span>smallset<span class="op">$</span>flight, 
                    <span class="dt">seg=</span>smallset<span class="op">$</span>seg, <span class="dt">vert=</span>smallset<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk)
<span class="kw">plot</span>(ranges)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-12-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(ranges, <span class="dt">cumulative=</span><span class="ot">TRUE</span>, <span class="dt">label=</span><span class="ot">TRUE</span>, <span class="dt">col=</span><span class="dv">3</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-12-2.png" width="672"></p>
<p>The overlap between the respective home ranges of all individuals can be described using <code><a href="../reference/homerangeoverlap.html">homerangeoverlap()</a></code> This returns three matrices: first, the linear distance represented in the union of the home ranges of each pair of individuals (<code>$either</code>), then the linear distance represented in the intersection (<code>$both</code>), then the proportional overlap (<code>$prop_both</code>), defined as intersection/union. Approximately 78% of the linear home range occupied by either individual 1 or 3 is shared by both of them.</p>
<p>The amount of overlap in home ranges can also be plotted using <code><a href="../reference/plothomerangeoverlap.html">plothomerangeoverlap()</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/homerangeoverlap.html">homerangeoverlap</a></span>(ranges)</code></pre></div>
<pre><code>## $either
##           1        2         3
## 1  99914.27 157177.9 106065.85
## 2 157177.89 141136.2 141136.24
## 3 106065.85 141136.2  88669.52
## 
## $both
##          1         2        3
## 1 99914.27  83872.62 82517.95
## 2 83872.62 141136.24 88669.52
## 3 82517.95  88669.52 88669.52
## 
## $prop_both
##           1         2         3
## 1 1.0000000 0.5336159 0.7779879
## 2 0.5336159 1.0000000 0.6282548
## 3 0.7779879 0.6282548 1.0000000</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/plothomerangeoverlap.html">plothomerangeoverlap</a></span>(ranges)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-13-1.png" width="480"></p>
<p><a name="Computing%20a%20matrix%20of%20network%20distances%20between%20all%20observations"></a></p>
<p><strong>Computing a matrix of network distances between all observations using <code><a href="../reference/riverdistancemat.html">riverdistancemat()</a></code></strong></p>
<p>A matrix of the river network distance between every observation and every other observation can also be calculated using <code><a href="../reference/riverdistancemat.html">riverdistancemat()</a></code>. A use for this function might be if the user wishes to calculate all distances at once, and subset later.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dmat &lt;-<span class="st"> </span><span class="kw"><a href="../reference/riverdistancemat.html">riverdistancemat</a></span>(smallset<span class="op">$</span>seg,smallset<span class="op">$</span>vert,Gulk)
<span class="kw">round</span>(dmat)[<span class="dv">1</span><span class="op">:</span><span class="dv">7</span>,<span class="dv">1</span><span class="op">:</span><span class="dv">7</span>]  <span class="co"># only showing the first 7 rows &amp; columns for clarity</span></code></pre></div>
<pre><code>##        1      2      3     4      5      6      7
## 1      0  83589    284 69994 101953  25605  83956
## 2  83589      0  83873 45678  22200 109194    367
## 3    284  83873      0 70278 102236  25322  84239
## 4  69994  45678  70278     0  64042  95599  46045
## 5 101953  22200 102236 64042      0 127558  22567
## 6  25605 109194  25322 95599 127558      0 109561
## 7  83956    367  84239 46045  22567 109561      0</code></pre>
<p>The <code>logical</code> argument can be used for subsetting, if the full network distance matrix is not needed. This capability is shown below, calculating the distance matrix only for observations occurring on segment number 2. The <code>ID</code> argument can be used with a vector of observation labels, to display row and column labels that may be easier to interpret than observation indices.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">logi1 &lt;-<span class="st"> </span>(smallset<span class="op">$</span>seg<span class="op">==</span><span class="dv">2</span>) 

<span class="co"># constructing observation labels</span>
obsID &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">"id"</span>,smallset<span class="op">$</span>id,<span class="st">"-flight"</span>,smallset<span class="op">$</span>flight) 

<span class="kw"><a href="../reference/riverdistancemat.html">riverdistancemat</a></span>(<span class="dt">seg=</span>smallset<span class="op">$</span>seg, <span class="dt">vert=</span>smallset<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk, <span class="dt">logical=</span>logi1, 
                 <span class="dt">ID=</span>obsID)</code></pre></div>
<pre><code>##             id1-flight3 id2-flight3 id3-flight1
## id1-flight3      0.0000   366.62343   326.28884
## id2-flight3    366.6234     0.00000    40.33459
## id3-flight1    326.2888    40.33459     0.00000</code></pre>
<p><a name="Computing%20a%20matrix%20of%20network%20distances%20between%20all%20observations%20of%20two%20different%20datasets"></a></p>
<p><strong>Computing a matrix of network distances between all observations of two different datasets using <code><a href="../reference/riverdistancetofrom.html">riverdistancetofrom()</a></code></strong></p>
<p>A matrix of river network distance between two location datasets can be calculated using <code><a href="../reference/riverdistancetofrom.html">riverdistancetofrom()</a></code>, which can be similarly subsetted using the <code>logical1</code> and <code>logical2</code> arguments. Row and column names can be added using the <code>ID1</code> and <code>ID2</code> arguments.</p>
<p>An example of the use of this function might be computation of distance between observations of instrumented fish and a set of fixed river locations, such as contaminant sites. In this case, a similar function <code><a href="../reference/upstreamtofrom.html">upstreamtofrom()</a></code> (discussed later) might be used, which would give the means to calculate up- or downstream distance from contaminant sites, with the option of examining flow-connectedness.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">streamlocs.seg &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">2</span>)
streamlocs.vert &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>)
streamlocs.ID &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"loc A"</span>,<span class="st">"loc B"</span>,<span class="st">"loc C"</span>)

logi2 &lt;-<span class="st"> </span>(smallset<span class="op">$</span>seg<span class="op">==</span><span class="dv">2</span>)
obsID &lt;-<span class="st"> </span><span class="kw">paste0</span>(<span class="st">"id"</span>,smallset<span class="op">$</span>id,<span class="st">"-flight"</span>,smallset<span class="op">$</span>flight)

<span class="kw"><a href="../reference/riverdistancetofrom.html">riverdistancetofrom</a></span>(<span class="dt">seg1=</span>streamlocs.seg, <span class="dt">vert1=</span>streamlocs.vert, <span class="dt">seg2=</span>smallset<span class="op">$</span>seg, 
                    <span class="dt">vert2=</span>smallset<span class="op">$</span>vert, <span class="dt">ID1=</span>streamlocs.ID, <span class="dt">ID2=</span>obsID, <span class="dt">logical2=</span>logi2, 
                    <span class="dt">rivers=</span>Gulk)</code></pre></div>
<pre><code>##       id1-flight3 id2-flight3 id3-flight1
## loc A   129.95819    496.5816    456.2470
## loc B    99.42056    267.2029    226.8683
## loc C   479.65380    113.0304    153.3650</code></pre>
<p><a name="Incorporating%20flow%20direction"></a></p>
</div>
<div id="incorporating-flow-direction" class="section level2">
<h2 class="hasAnchor">
<a href="#incorporating-flow-direction" class="anchor"></a>Incorporating flow direction</h2>
<p><a href="#Defining%20flow%20direction%20of%20a%20river%20network">Defining flow direction of a river network</a></p>
<p><a href="#Calculating%20flow%20direction%20and%20directional%20network%20distance">Calculating flow direction and directional network distance</a></p>
<p><a href="#Automations%20of%20flow%20direction%20and%20directional%20network%20distance">Automations of flow direction and directional network distance</a></p>
<p><a name="Defining%20flow%20direction%20of%20a%20river%20network"></a></p>
<p><strong>Defining flow direction of a river network using <code><a href="../reference/setmouth.html">setmouth()</a></code></strong></p>
<p>Flow direction and directional (upstream) distance can also be calculated. For this to be accomplished, the segment and vertex of the river “mouth”, or lowest point must first be identified. The segment containing the river mouth can be visually identified from a plot of the river network. In the Gulkana River example, the lowest segment happens to be segment 1. Identifying the lowest vertex of segment 1 can be done using the plot produced by <code><a href="../reference/showends.html">showends()</a></code>, shown below. In this case, the mouth vertex happens to be vertex 1. This will not necessarily be the case. After importing a shapefile into R, the segment vertices will be stored in sequential order, but not necessarily by flow direction. Specifying the segment and vertex coordinates of the river network mouth can be done using <code><a href="../reference/setmouth.html">setmouth()</a></code> as shown below, though it can also be set manually by direct assignment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/showends.html">showends</a></span>(<span class="dt">seg=</span><span class="dv">1</span>,<span class="dt">rivers=</span>Gulk)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-17-1.png" width="480"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Gulk1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/setmouth.html">setmouth</a></span>(<span class="dt">seg=</span><span class="dv">1</span>, <span class="dt">vert=</span><span class="dv">1</span>, <span class="dt">rivers=</span>Gulk)</code></pre></div>
<p><a name="Calculating%20flow%20direction%20and%20directional%20network%20distance"></a></p>
<p><strong>Calculating flow direction using <code><a href="../reference/riverdirection.html">riverdirection()</a></code> and directional network distance using <code><a href="../reference/upstream.html">upstream()</a></code></strong></p>
<p>If the flow direction has been established by specifying the river network mouth, river direction can be calculated using <code><a href="../reference/riverdirection.html">riverdirection()</a></code>, and upstream distance can be calculated using <code><a href="../reference/upstream.html">upstream()</a></code>. If the input river locations are flow-connected, <code><a href="../reference/riverdirection.html">riverdirection()</a></code> returns “up” if the second location is upstream of the first and “down” if downstream. In the flow-connected case, <code><a href="../reference/upstream.html">upstream()</a></code> returns the network distance as positive if the second location is upstream of the first, and negative if downstream. If the input locations are not flow-connected, <code><a href="../reference/riverdirection.html">riverdirection()</a></code> returns “up” if the total upstream distance is greater than the total downstream distance, and “down” otherwise. In the non flow-connected case, upstream distance in <code><a href="../reference/upstream.html">upstream()</a></code> can return one of two things, depending on the user’s research intent. Specifying <code>net=TRUE</code> will return the “net” distance (upstream distance - downstream distance between the two locations). Specifying <code>net=FALSE</code> (the default) will return the total distance between the two locations, with the sign depending on whether the upstream distance exceeds the downstream distance.</p>
<p>For example, the route between two points goes downstream along a river for 100m, then up 20m on a tributary. Specifying <code>net=TRUE</code> will return a distance of -80m. Specifying <code>net=FALSE</code> will return a distance of -120m.</p>
<p>Specifying <code>flowconnected=TRUE</code> in both <code><a href="../reference/riverdirection.html">riverdirection()</a></code> and <code><a href="../reference/upstream.html">upstream()</a></code> will only return distances or directions if the input locations are flow-connected, and will return <code>NA</code> otherwise.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/zoomtoseg.html">zoomtoseg</a></span>(<span class="dt">seg=</span><span class="kw">c</span>(<span class="dv">6</span>,<span class="dv">3</span>), <span class="dt">rivers=</span>Gulk)
<span class="kw"><a href="../reference/riverpoints.html">riverpoints</a></span>(<span class="dt">seg=</span><span class="kw">c</span>(<span class="dv">6</span>,<span class="dv">4</span>), <span class="dt">vert=</span><span class="kw">c</span>(<span class="dv">250</span>,<span class="dv">250</span>), <span class="dt">col=</span><span class="dv">4</span>, <span class="dt">pch=</span><span class="dv">15</span>, <span class="dt">rivers=</span>Gulk1)
<span class="co">#riverdistance(startseg=6, endseg=4, startvert=250, endvert=250, rivers=Gulk1, map=TRUE)</span>
<span class="kw">text</span>(<span class="kw">c</span>(<span class="fl">859122.4</span>, <span class="fl">872104.1</span>), <span class="kw">c</span>(<span class="fl">6964127.4</span>,<span class="fl">6969741.0</span>), <span class="dt">pos=</span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>), 
     <span class="dt">labels=</span><span class="kw">c</span>(<span class="st">"beginning"</span>, <span class="st">"end"</span>))</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-18-1.png" width="480"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/riverdirection.html">riverdirection</a></span>(<span class="dt">startseg=</span><span class="dv">6</span>, <span class="dt">endseg=</span><span class="dv">4</span>, <span class="dt">startvert=</span><span class="dv">250</span>, <span class="dt">endvert=</span><span class="dv">250</span>, <span class="dt">rivers=</span>Gulk1)</code></pre></div>
<pre><code>## [1] "down"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/upstream.html">upstream</a></span>(<span class="dt">startseg=</span><span class="dv">6</span>, <span class="dt">endseg=</span><span class="dv">4</span>, <span class="dt">startvert=</span><span class="dv">250</span>, <span class="dt">endvert=</span><span class="dv">250</span>, <span class="dt">rivers=</span>Gulk1, <span class="dt">net=</span><span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] -66235.32</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/upstream.html">upstream</a></span>(<span class="dt">startseg=</span><span class="dv">6</span>, <span class="dt">endseg=</span><span class="dv">4</span>, <span class="dt">startvert=</span><span class="dv">250</span>, <span class="dt">endvert=</span><span class="dv">250</span>, <span class="dt">rivers=</span>Gulk1, <span class="dt">net=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] -28636.75</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/upstream.html">upstream</a></span>(<span class="dt">startseg=</span><span class="dv">6</span>, <span class="dt">endseg=</span><span class="dv">4</span>, <span class="dt">startvert=</span><span class="dv">250</span>, <span class="dt">endvert=</span><span class="dv">250</span>, <span class="dt">rivers=</span>Gulk1, 
         <span class="dt">flowconnected=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] NA</code></pre>
<p><a name="Automations%20of%20flow%20direction%20and%20directional%20network%20distance"></a></p>
<p><strong>Automations of flow direction and directional network distance</strong></p>
<p>River direction and upstream distance are also applied in functions <code><a href="../reference/riverdirectionseq.html">riverdirectionseq()</a></code> and <code><a href="../reference/upstreamseq.html">upstreamseq()</a></code> which work like <code><a href="../reference/riverdistanceseq.html">riverdistanceseq()</a></code>, <code><a href="../reference/riverdirectionmatbysurvey.html">riverdirectionmatbysurvey()</a></code> and <code><a href="../reference/upstreammatbysurvey.html">upstreammatbysurvey()</a></code> which work like <code><a href="../reference/riverdistancematbysurvey.html">riverdistancematbysurvey()</a></code>, <code><a href="../reference/riverdirectionmat.html">riverdirectionmat()</a></code> and <code><a href="../reference/upstreammat.html">upstreammat()</a></code> which work like <code><a href="../reference/riverdistancemat.html">riverdistancemat()</a></code>, and <code>riverdirectiontofrom</code> and <code>upstreamtofrom</code> which work like <code>riverdistancetofrom</code>. The <code><a href="../reference/upstreamseq.html">upstreamseq()</a></code>, <code><a href="../reference/upstreammatbysurvey.html">upstreammatbysurvey()</a></code>, and <code><a href="../reference/upstreammat.html">upstreammat()</a></code> use the additional <code>net=</code> argument, and all river direction and upstream distance functions use the additional <code>flowconnected=</code> argument.</p>
<p><a name="Allowing%20different%20route-detection%20algorithms%20a%20possible%20time-saver"></a></p>
</div>
<div id="allowing-different-route-detection-algorithms-a-possible-time-saver" class="section level2">
<h2 class="hasAnchor">
<a href="#allowing-different-route-detection-algorithms-a-possible-time-saver" class="anchor"></a>Allowing different route-detection algorithms: a possible time-saver</h2>
<p>Currently three algorithms are implemented to detect routes between river locations, with the functions automatically selecting the most appropriate unless another is specified. Dijkstra’s algorithm is used by default (<code>algorithm="Dijkstra"</code>), which returns the shortest route in the presence of braiding. The sequential algorithm (<code>algorithm="sequential"</code>) may be used, which returns the first complete route detected. The sequential algorithm is much slower and is not recommended in nearly all cases, but is retained as an option for certain checks.</p>
<p>If many distance calculations or a more sophisticated analysis is to be conducted, it is highly recommended to run <code><a href="../reference/buildsegroutes.html">buildsegroutes()</a></code>, allowing <code>algorithm="segroutes"</code> to be used. This adds route and distance information to the river network object, greatly simplifying distance calculation, and reducing processing time for each distance calculation. The <code><a href="../reference/buildsegroutes.html">buildsegroutes()</a></code> function also includes an option to calculate a distance lookup table as well. This may take a few seconds to run, but will reduce computation times even further - cutting the already-fast segment route algorithm time by 50-80%. Lookup tables can be calculated directly using <code><a href="../reference/buildlookup.html">buildlookup()</a></code>, but may be extremely slow to calculate without running <code><a href="../reference/buildsegroutes.html">buildsegroutes()</a></code> first.</p>
<p>In the example below, distance is calculated between the two points in a complex river network, using all three route detection algorithms, and calculating the time requirement for a single calculation.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(abstreams)

tstart &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw"><a href="../reference/riverdistance.html">riverdistance</a></span>(<span class="dt">startseg=</span><span class="dv">120</span>, <span class="dt">startvert=</span><span class="dv">10</span>, <span class="dt">endseg=</span><span class="dv">131</span>, <span class="dt">endvert=</span><span class="dv">10</span>, <span class="dt">rivers=</span>abstreams, 
              <span class="dt">algorithm=</span><span class="st">"sequential"</span>)</code></pre></div>
<pre><code>## [1] 68937.76</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Sys.time</span>()<span class="op">-</span><span class="st"> </span>tstart</code></pre></div>
<pre><code>## Time difference of 0.2916193 secs</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tstart &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw"><a href="../reference/riverdistance.html">riverdistance</a></span>(<span class="dt">startseg=</span><span class="dv">120</span>, <span class="dt">startvert=</span><span class="dv">10</span>, <span class="dt">endseg=</span><span class="dv">131</span>, <span class="dt">endvert=</span><span class="dv">10</span>, <span class="dt">rivers=</span>abstreams, 
              <span class="dt">algorithm=</span><span class="st">"Dijkstra"</span>)</code></pre></div>
<pre><code>## [1] 68937.76</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Sys.time</span>()<span class="op">-</span><span class="st"> </span>tstart</code></pre></div>
<pre><code>## Time difference of 0.004442215 secs</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tstart &lt;-<span class="st"> </span><span class="kw">Sys.time</span>()
<span class="kw"><a href="../reference/riverdistance.html">riverdistance</a></span>(<span class="dt">startseg=</span><span class="dv">120</span>, <span class="dt">startvert=</span><span class="dv">10</span>, <span class="dt">endseg=</span><span class="dv">131</span>, <span class="dt">endvert=</span><span class="dv">10</span>, <span class="dt">rivers=</span>abstreams)</code></pre></div>
<pre><code>## [1] 68937.76</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Note: it is not necessary to specify the algorithm here: the distance function</span>
<span class="co"># will automatically select the fastest algorithm unless otherwise specified.</span>
<span class="kw">Sys.time</span>()<span class="op">-</span><span class="st"> </span>tstart</code></pre></div>
<pre><code>## Time difference of 0.001503468 secs</code></pre>
<p>In this case, building segment routes and distance lookup tables takes a little more than a second, even with a fairly complex river network. Calculating a single distance afterwards takes about 80 microseconds using segment routes and about 25 microseconds using the lookup tables. This dramatically saves time if multiple distances are to be computed, such as in a large matrix of distances, or multiple analyses. Kernel density and K-function analysis is probably prohibitively slow otherwise.</p>
<p><a name="Beyond%20individuals%20summarizing%20or%20plotting%20at%20the%20dataset%20level"></a></p>
</div>
<div id="beyond-individuals-summarizing-or-plotting-at-the-dataset-level" class="section level2">
<h2 class="hasAnchor">
<a href="#beyond-individuals-summarizing-or-plotting-at-the-dataset-level" class="anchor"></a>Beyond individuals: summarizing or plotting at the dataset level</h2>
<p><a href="#Calculating%20and%20plotting%20kernel%20density">Calculating and plotting kernel density</a></p>
<p><a href="#Spatial%20data%20spread%20for%20each%20flight%20event">Spatial data spread for each flight event</a></p>
<p><a href="#Plotting%20clustering%20or%20dispersal%20using%20K-functions">Plotting clustering or dispersal using K-functions</a></p>
<p><a href="#Summarizing%20up-river%20position">Summarizing up-river position</a></p>
<p><a href="#Plotting%20a%20summary%20matrix%20or%20distance%20sequence">Plotting a summary matrix or distance sequence</a></p>
<p><a href="#Plotting%20all%20upstream%20movements">Plotting all upstream movements</a></p>
<p><a name="Calculating%20and%20plotting%20kernel%20density"></a></p>
<p><strong>Calculating and plotting kernel density using <code><a href="../reference/riverdensity.html">riverdensity()</a></code> and <code><a href="../reference/plot.riverdensity.html">plotriverdensity()</a></code></strong></p>
<p>A method has been provided to display kernel density calculated from point data, using river network distance. The <code><a href="../reference/makeriverdensity.html">makeriverdensity()</a></code> function calculates scaled kernel density at approximately regularly-spaced river network locations, with the linear resolution specified by the optional <code>resolution=</code> argument. A gaussian (normal) kernel is used by default, but a rectangular (simple density) kernel can be used as well. The <code>survey=</code> argument may also be used with a vector of survey identifiers corresponding to the point data. If the <code>survey=</code> argument is used, <code><a href="../reference/makeriverdensity.html">makeriverdensity()</a></code> will calculate separate densities for each unique survey, and a method of <code>plot()</code> will produce a separate plot for each unique survey.</p>
<p>The <code>plot()</code> function method can display densities using line thickness, color, or both. For additional plotting arguments including possible color ramps, see <code><a href="../reference/plot.riverdensity.html">?plot.riverdensity</a></code>.</p>
<p>Densities for nine of the ten Fakefish surveys are shown below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(Gulk, fakefish)
fakefish_density &lt;-<span class="st"> </span><span class="kw"><a href="../reference/makeriverdensity.html">makeriverdensity</a></span>(<span class="dt">seg=</span>fakefish<span class="op">$</span>seg, <span class="dt">vert=</span>fakefish<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk, 
  <span class="dt">survey=</span>fakefish<span class="op">$</span>flight.date, <span class="dt">resolution=</span><span class="dv">2000</span>, <span class="dt">bw=</span><span class="dv">10000</span>)
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>))
<span class="kw">plot</span>(<span class="dt">x=</span>fakefish_density, <span class="dt">ramp=</span><span class="st">"blue"</span>, <span class="dt">dark=</span><span class="fl">0.85</span>, <span class="dt">maxlwd=</span><span class="dv">15</span>,
                 <span class="dt">whichplots=</span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">8</span>,<span class="dv">10</span>))   <span class="co"># showing only nine plots for clarity</span></code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-22-1.png" width="720"></p>
<p><a name="Spatial%20data%20spread%20for%20each%20flight%20event"></a></p>
<p><strong>An alternate use of <code><a href="../reference/homerange.html">homerange()</a></code> to give the spatial data spread for each flight event</strong></p>
<p>The <code><a href="../reference/homerange.html">homerange()</a></code> function could also be used to give a measure of the spatial spread of observations for each flight event, by using the flight identifier instead of individual identifier in the <code>unique=</code> argument.</p>
<p>In this case, the observations are the most closely spaced in the first flight event, and the most widely spaced in the August 11 flight event. Interestingly, the density plot of the August 11 flight shows many of the the individuals to be located near one another, but spread to multiple tributaries, with little presence in between. Considering this event to be the largest spread may still be appropriate, depending on the study, since all individuals were observed as concentrated in the lower mainstem on April 1.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/homerange.html">homerange</a></span>(<span class="dt">unique=</span>fakefish<span class="op">$</span>flight.date, <span class="dt">seg=</span>fakefish<span class="op">$</span>seg, <span class="dt">vert=</span>fakefish<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk)
x</code></pre></div>
<pre><code>## Minumum home ranges associated with each individual 
##  
##            ID     range
## 1  2015-04-01  66026.33
## 2  2015-04-19 145231.00
## 3  2015-06-01  84856.73
## 4  2015-06-21 136195.56
## 5  2015-07-07 176480.46
## 6  2015-08-11 235446.27
## 7  2015-09-05 171769.53
## 8  2015-09-20 130524.91
## 9  2015-10-29 140431.19
## 10 2015-11-25 124827.73</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(x<span class="op">$</span>range, <span class="dt">type=</span><span class="st">'b'</span>, <span class="dt">xaxt=</span><span class="st">'n'</span>, <span class="dt">xlab=</span><span class="st">""</span>, <span class="dt">ylab=</span><span class="st">"range (m)"</span>, <span class="dt">cex.axis=</span>.<span class="dv">6</span>)
<span class="kw">axis</span>(<span class="dv">1</span>,<span class="dt">at=</span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>,<span class="dt">labels=</span><span class="kw">sort</span>(<span class="kw">unique</span>(fakefish<span class="op">$</span>flight.date)), <span class="dt">cex.axis=</span>.<span class="dv">6</span>, <span class="dt">las=</span><span class="dv">3</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-23-1.png" width="480"></p>
<p><a name="Plotting%20clustering%20or%20dispersal%20using%20K-functions"></a></p>
<p><strong>Plotting clustering or dispersal using K-functions, with <code><a href="../reference/kfunc.html">kfunc()</a></code></strong></p>
<p>K-functions, defined here as the average proportion of additional individuals located within a given distance of each individual, can be a useful tool for investigating evidence of clustering or dispersal. Calling <code><a href="../reference/kfunc.html">kfunc()</a></code> and specifying the flight indentifier will result in a sequence of plots, each displaying the K-function associated with each survey.</p>
<p>Unless otherwise specified, each plot will be overlayed with a confidence envelope, calculated by resampling all within-survey distances, thus creating a null distribution under the assumption that clustering is independent of survey. Thus, a K-function above the envelope at a small distance range can be seen as evidence that locations were more clustered than expected for that survey; conversely, a K-function below the envelope at a small distance range can be seen as evidence that locations were more dispersed than expected for that survey.</p>
<p>The plots below show relatively high amounts of clustering for the 2015-04-01 and 2015-09-20 surveys. The 2015-07-07 and especially 2015-08-11 surveys show possible clustering at small distances and very strong dispersal at medium distances, which can be corroborated with the density maps shown above..</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>))
<span class="kw"><a href="../reference/kfunc.html">kfunc</a></span>(<span class="dt">seg=</span>fakefish<span class="op">$</span>seg, <span class="dt">vert=</span>fakefish<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk, <span class="dt">survey=</span>fakefish<span class="op">$</span>flight.date,
     <span class="dt">maxdist=</span><span class="dv">200000</span>, <span class="dt">whichplots=</span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">8</span>,<span class="dv">10</span>))   <span class="co"># showing only nine plots for clarity</span></code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-24-1.png" width="720"></p>
<p><a name="Summarizing%20up-river%20position"></a></p>
<p><strong>Summarizing up-river position, defined as distance from mouth, using <code><a href="../reference/mouthdist.html">mouthdist()</a></code> for one observation and <code><a href="../reference/mouthdistbysurvey.html">mouthdistbysurvey()</a></code> for a dataset</strong></p>
<p>In some cases, a meaningful summary measure may be the up-river position of each observation. Distance between an individual observation and the river mouth can be calculated using <code><a href="../reference/mouthdist.html">mouthdist()</a></code>. In the case of multiple observations of a set of individuals, a summary matrix can be calculated using <code><a href="../reference/mouthdistbysurvey.html">mouthdistbysurvey()</a></code>, which returns a matrix of distances from the river mouth, with each row corresponding to a unique individual and each column corresponding to a unique survey.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/mouthdist.html">mouthdist</a></span>(<span class="dt">seg=</span>fakefish<span class="op">$</span>seg[<span class="dv">1</span>], <span class="dt">vert=</span>fakefish<span class="op">$</span>vert[<span class="dv">1</span>], <span class="dt">rivers=</span>Gulk)</code></pre></div>
<pre><code>## [1] 56016.35</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mouthdistbysurvey.html">mouthdistbysurvey</a></span>(<span class="dt">unique=</span>fakefish<span class="op">$</span>fish.id, <span class="dt">survey=</span>fakefish<span class="op">$</span>flight,
    <span class="dt">seg=</span>fakefish<span class="op">$</span>seg, <span class="dt">vert=</span>fakefish<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk)

<span class="kw">round</span>(x)</code></pre></div>
<pre><code>##        1      2      3      4      5      6      7      8      9     10
## 1  26535 121619     NA 131182 162899     NA     NA 105966 101516  65373
## 2  10333     NA     NA 105166     NA     NA     NA  99972     NA     NA
## 3     NA   7581 106455     NA 150986 164013 125509 106237 102427  14046
## 4     NA 108482 117334     NA 145338 131182 146021     NA     NA   4878
## 6     NA 125610     NA     NA     NA 165423 105344     NA 108398     NA
## 7  10153  75961  88672 155589 131218     NA     NA     NA     NA     NA
## 8  56016     NA 106901     NA     NA     NA 166606 104745  95707  64041
## 9  46998  96425 130164 106331     NA     NA     NA 105344     NA 122739
## 10 36393     NA     NA  99958 132170     NA     NA  82537  75916     NA
## 11 76180     NA     NA     NA     NA 139313     NA 104850  11434 107265
## 12    NA  63984     NA 106901     NA     NA 130796     NA     NA  97886
## 13    NA     NA     NA 120679 145370 174795 142849     NA     NA     NA
## 14 31502     NA  80465 105835 144800 140778 106050     NA 126070  56293
## 15    NA  92050 131218     NA 147101 130009     NA     NA  52751     NA
## 16 45619     NA     NA     NA     NA     NA 106656 104879 117856   8714
## 17 38397     NA 105165     NA 133124 160212     NA     NA     NA     NA
## 18    NA  83037  86457 153561     NA     NA  90940     NA     NA 129706
## 19    NA 103833     NA 107267     NA 196411     NA 130493  89983     NA
## 20    NA     NA 106260     NA 136400 141994 104879  29574     NA     NA</code></pre>
<p><a name="Plotting%20a%20summary%20matrix%20or%20distance%20sequence"></a></p>
<p><strong>Plotting the summary matrix from <code><a href="../reference/mouthdistbysurvey.html">mouthdistbysurvey()</a></code> or other distance sequence using <code><a href="../reference/plotseq.html">plotseq()</a></code></strong></p>
<p>The resulting matrix of up-river position returned from <code><a href="../reference/mouthdistbysurvey.html">mouthdistbysurvey()</a></code>, or another distance sequence returned from <code><a href="../reference/riverdistanceseq.html">riverdistanceseq()</a></code> or <code><a href="../reference/upstreamseq.html">upstreamseq()</a></code>, can be plotted using <code><a href="../reference/plotseq.html">plotseq()</a></code>. A few types of plots are available, with two shown below. Additional <code>type=</code> arguments can be seen by calling <code><a href="../reference/plotseq.html">?plotseq</a></code>.</p>
<p>The user is cautioned to use any plots returned as descriptive tools only, as ANOVA-type inference would likely be inappropriate without accounting for repeated-measures and/or serial autocorrelation.</p>
<p>In the example below, the plot shows evidence of the instrumented fish beginning the sampling period near the river mouth, then migrating upriver, and finally ending the sampling period near the mouth.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mouthdistbysurvey.html">mouthdistbysurvey</a></span>(<span class="dt">unique=</span>fakefish<span class="op">$</span>fish.id, <span class="dt">survey=</span>fakefish<span class="op">$</span>flight.date,
    <span class="dt">seg=</span>fakefish<span class="op">$</span>seg, <span class="dt">vert=</span>fakefish<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw"><a href="../reference/plotseq.html">plotseq</a></span>(<span class="dt">seqbysurvey=</span>x)
<span class="kw"><a href="../reference/plotseq.html">plotseq</a></span>(<span class="dt">seqbysurvey=</span>x, <span class="dt">type=</span><span class="st">"dotline"</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-26-1.png" width="720"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">1</span>))</code></pre></div>
<p>Depending on the study, <code><a href="../reference/plotseq.html">plotseq()</a></code> may be useful in plotting the upstream distance between observations of all individual, as calculated in <code><a href="../reference/upstreamseq.html">upstreamseq()</a></code>. It is worth noting that the outputs from both <code><a href="../reference/upstreamseq.html">upstreamseq()</a></code> and <code><a href="../reference/riverdistanceseq.html">riverdistanceseq()</a></code> may have many empty cells, if individuals were missed on any flights. For the purpose of clarity, the default plot type is used below, which produces boxplots. However, in this case, a jittered dotplot may be more appropriate due to the small sample sizes, and can be produced by specifying <code>type="dotplot"</code>.</p>
<p>In this case, the plots show evidence that movement was generally up-river between flights 1 and 2 and between flights 2 and 3, that there was the greatest variability in upstream movement between flights 5 and 6, and that movement was generally down-river in the latter part of the study.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw"><a href="../reference/upstreamseq.html">upstreamseq</a></span>(<span class="dt">unique=</span>fakefish<span class="op">$</span>fish.id, <span class="dt">survey=</span>fakefish<span class="op">$</span>flight, <span class="dt">seg=</span>fakefish<span class="op">$</span>seg,
                 <span class="dt">vert=</span>fakefish<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk)
<span class="kw">round</span>(x)</code></pre></div>
<pre><code>##    1 to 2 2 to 3 3 to 4 4 to 5  5 to 6  6 to 7 7 to 8 8 to 9 9 to 10
## 1   95084     NA     NA  31717      NA      NA     NA -54220  -36143
## 3      NA  98874     NA     NA  161737 -136261 -78484  -3810  -88381
## 4      NA   8852     NA     NA  -14156   14839     NA     NA      NA
## 6      NA     NA     NA     NA      NA  -62068     NA     NA      NA
## 7   65807  12711  66918 -24372      NA      NA     NA     NA      NA
## 8      NA     NA     NA     NA      NA      NA -62652  -9038  -31666
## 9   49427  33739 -83233     NA      NA      NA     NA     NA      NA
## 10     NA     NA     NA  32212      NA      NA     NA  -6621      NA
## 11     NA     NA     NA     NA      NA      NA     NA -93416   95831
## 13     NA     NA     NA 112787  166903  -52141     NA     NA      NA
## 14     NA     NA  33038  41936 -132316  -93566     NA     NA  -69777
## 15     NA  70005     NA     NA -123847      NA     NA     NA      NA
## 16     NA     NA     NA     NA      NA      NA  -1777  69473 -109142
## 17     NA     NA     NA     NA  140074      NA     NA     NA      NA
## 18     NA   3419  67104     NA      NA      NA     NA     NA      NA
## 19     NA     NA     NA     NA      NA      NA     NA -67214      NA
## 20     NA     NA     NA     NA  125132  -38174 -75305     NA      NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw"><a href="../reference/plotseq.html">plotseq</a></span>(<span class="dt">seqbysurvey=</span>x)

<span class="kw"><a href="../reference/plotseq.html">plotseq</a></span>(<span class="dt">seqbysurvey=</span>x, <span class="dt">type=</span><span class="st">"dotplot"</span>)
<span class="kw">abline</span>(<span class="dt">h=</span><span class="dv">0</span>, <span class="dt">lty=</span><span class="dv">3</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-27-1.png" width="720"></p>
<p><a name="Plotting%20all%20upstream%20movements"></a></p>
<p><strong>Plotting all upstream movements using <code><a href="../reference/matbysurveylist.html">matbysurveylist()</a></code> and <code><a href="../reference/plotmatbysurveylist.html">plotmatbysurveylist()</a></code></strong></p>
<p>In a more generalized application, the <code><a href="../reference/matbysurveylist.html">matbysurveylist()</a></code> function calculates the distances or upstream distances, between each pair of observation events, for all individuals. Functionally, this is a summary of the outputs of <code><a href="../reference/riverdistancematbysurvey.html">riverdistancematbysurvey()</a></code> or <code><a href="../reference/upstreammatbysurvey.html">upstreammatbysurvey()</a></code>, but for all individuals in a dataset. The output from <code><a href="../reference/matbysurveylist.html">matbysurveylist()</a></code> can then be plotted using <code><a href="../reference/plotmatbysurveylist.html">plotmatbysurveylist()</a></code>, providing a one-plot summary of all movements within a dataset. It is recommended to use the default <code>method="upstream"</code> in <code><a href="../reference/matbysurveylist.html">matbysurveylist()</a></code>, which calculates directional (upstream) distances, which will result in a more informative plot.</p>
<p>The output plot is the upper triangle of a matrix of plots, in which plot <code>[i,j]</code> represents the upstream distances traveled between observation <code>i</code> and observation <code>j</code>, for all individuals observed in those observations. Each plot is overlayed with a horizontal line at an upstream distance of zero, for an illustration of up-river or down-river movement trend for that pairwise movement. It is worth noting that all sequential pairings of events (first to second, second to third, etc.) fall on the lower edge of the triangle, and this sequence of plots is the same as those given by <code><a href="../reference/plotseq.html">plotseq()</a></code> in the previous example.</p>
<p>Three types of plots can be produced using the <code>type=</code> argument. The default boxplot type (<code>type="boxplot"</code>) is shown below. Alternately, if the <code>type=</code> argument is set to <code>"confint"</code>, each plot gives a line showing the extent of an approximate 95% confidence interval for the mean upstream distance traveled. Inference should be made with caution, as sample sizes are likely to be small, and no attempt has been made at using a family-wise confidence level. However, plotting confidence intervals may be further illustrative of trend. A jittered dotplot may be produced by specifying <code>type="dotplot"</code>, which will be the most appropriate in the case of small sample sizes. The default boxplot is shown below for the purpose of clarity, but a jittered dotplot would likely be a better choice in this instance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">matbysurveylist &lt;-<span class="st"> </span><span class="kw"><a href="../reference/matbysurveylist.html">matbysurveylist</a></span>(<span class="dt">unique=</span>fakefish<span class="op">$</span>fish.id, <span class="dt">survey=</span>fakefish<span class="op">$</span>flight, <span class="dt">seg=</span>fakefish<span class="op">$</span>seg, 
                         <span class="dt">vert=</span>fakefish<span class="op">$</span>vert, <span class="dt">rivers=</span>Gulk)
<span class="kw"><a href="../reference/plotmatbysurveylist.html">plotmatbysurveylist</a></span>(matbysurveylist)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-28-1.png" width="480"></p>
<p><a name="Editing%20a%20river%20network%20object,%20or%20fixing%20a%20messy%20one"></a></p>
</div>
<div id="editing-a-river-network-object-or-fixing-a-messy-one" class="section level2">
<h2 class="hasAnchor">
<a href="#editing-a-river-network-object-or-fixing-a-messy-one" class="anchor"></a>Editing a river network object, or fixing a messy one</h2>
<p><a href="#All-purpose%20river%20network%20cleanup">All-purpose river network cleanup</a></p>
<p><a href="#Issue%20the%20river%20network%20contains%20unneeded%20or%20unconnected%20segments">Issue: the river network contains unneeded or unconnected segments</a></p>
<p><a href="#Issue%20the%20river%20network%20contains%20sequential%20runs%20of%20segments%20that%20do%20not%20otherwise%20branch">Issue: the river network contains sequential “runs” of segments that do not otherwise branch</a></p>
<p><a href="#Issue%20the%20river%20network%20segments%20do%20not%20break%20where%20they%20should">Issue: the river network segments do not break where they should</a></p>
<p><a href="#Issue%20segments%20that%20should%20connect%20do%20not">Issue: segments that should connect do not</a></p>
<p><a href="#Issue%20the%20river%20network%20contains%20segments%20that%20are%20smaller%20than%20the%20connectivity%20tolerance">Issue: the river network contains segments that are smaller than the connectivity tolerance</a></p>
<p><a href="#Issue%20A%20long%20straight-line%20section%20of%20the%20river%20network%20does%20not%20contain%20vertices%20between%20endpoints">Issue: A long straight-line section of the river network does not contain vertices between endpoints</a></p>
<p>Ideally, the shapefile used to define a river network object should be refined in GIS <em>before</em> importing into R. That being said, there are sure to be instances in which it is advantageous or necessary to make changes to the river network object within R.</p>
<p><a name="All-purpose%20river%20network%20cleanup"></a></p>
<p><strong>All-purpose river network cleanup using <code><a href="../reference/cleanup.html">cleanup()</a></code></strong></p>
<p>In many cases, the <code><a href="../reference/cleanup.html">cleanup()</a></code> function will be the recommended first step in fixing a messy river network object after importing it. The <code><a href="../reference/cleanup.html">cleanup()</a></code> function should be called within the console, and interactively calls the editing functions in sequence. It then returns a new, edited river network object which can be edited further, or used as is. It may even be the most straightforward to call <code><a href="../reference/cleanup.html">cleanup()</a></code> multiple times. If there were spatial oddities with the parent shapefile (vertices out of order, or strange “jumps” in segments), the <code><a href="../reference/cleanup_verts.html">cleanup_verts()</a></code> function interactively steps through each individual segment, providing a means to edit the vertices of each segment if needed.</p>
<p>Usage will look like</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(abstreams0)  <span class="co"># a messy river network</span>
abstreams_fixed &lt;-<span class="st"> </span><span class="kw"><a href="../reference/cleanup.html">cleanup</a></span>(abstreams0)  <span class="co"># fixing many problems</span></code></pre></div>
<p><a name="Issue%20the%20river%20network%20contains%20unneeded%20or%20unconnected%20segments"></a></p>
<p><strong>Issue: the river network contains unneeded or unconnected segments - fixes using <code><a href="../reference/trimriver.html">trimriver()</a></code>, <code><a href="../reference/trimtopoints.html">trimtopoints()</a></code>, and <code><a href="../reference/removeunconnected.html">removeunconnected()</a></code></strong></p>
<p>This is a very likely issue, particularly if the network was imported without changes in a GIS environment. River network segments can be manually removed using <code><a href="../reference/trimriver.html">trimriver()</a></code>, as shown below. Using the argument <code>trim=</code> removes the specified segments, and using the argument <code>trimto=</code> removes all <em>but</em> the specified segments. The example below is fairly simplistic, but illustrates the usage of the <code>trim=</code> and <code>trimto=</code> arguments.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Gulk_trim1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/trimriver.html">trimriver</a></span>(<span class="dt">trim=</span><span class="kw">c</span>(<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>), <span class="dt">rivers=</span>Gulk)
Gulk_trim2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/trimriver.html">trimriver</a></span>(<span class="dt">trimto=</span><span class="kw">c</span>(<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>), <span class="dt">rivers=</span>Gulk)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))
<span class="kw">plot</span>(<span class="dt">x=</span>Gulk, <span class="dt">main=</span><span class="st">"original"</span>)
<span class="kw">plot</span>(<span class="dt">x=</span>Gulk_trim1, <span class="dt">main=</span><span class="st">"trim=c(10,11,12,13,14)"</span>)
<span class="kw">plot</span>(<span class="dt">x=</span>Gulk_trim2, <span class="dt">main=</span><span class="st">"trimto=c(10,11,12,13,14)"</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-30-1.png" width="720"></p>
<p>It is also possible to trim a river network to include only segments that are within a spatial tolerance of a set of X-Y points. The <code><a href="../reference/trimtopoints.html">trimtopoints()</a></code> function offers three methods of doing this. Specifying <code>method="snap"</code> (the default) returns a river network made up only of the closest segments to the input points. This is the simplest method, but may result in spatial gaps, as shown in the example below. Specifying <code>method="snaproute"</code> returns a network of the closest segments to the input points, but also includes any segments necessary to maintain a connected network. Specifying <code>method="buffer"</code> returns a river network made up of segments with endpoints or midpoints located within a specified “buffer” distance of the input points. This may be advantageous if the user wants to include segments that are near, but not directly proximal, to the input points.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(Kenai3)
x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">174185</span>, <span class="dv">172304</span>, <span class="dv">173803</span>, <span class="dv">176013</span>)
y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1173471</span>, <span class="dv">1173345</span>, <span class="dv">1163638</span>, <span class="dv">1164801</span>)
Kenai3.buf1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/trimtopoints.html">trimtopoints</a></span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">rivers=</span>Kenai3, <span class="dt">method=</span><span class="st">"snap"</span>)
Kenai3.buf2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/trimtopoints.html">trimtopoints</a></span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">rivers=</span>Kenai3, <span class="dt">method=</span><span class="st">"snaproute"</span>)
Kenai3.buf3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/trimtopoints.html">trimtopoints</a></span>(<span class="dt">x=</span>x, <span class="dt">y=</span>y, <span class="dt">rivers=</span>Kenai3, <span class="dt">method=</span><span class="st">"buffer"</span>, <span class="dt">dist=</span><span class="dv">5000</span>)

<span class="kw">plot</span>(<span class="dt">x=</span>Kenai3, <span class="dt">main=</span><span class="st">"original"</span>)
<span class="kw">points</span>(x, y, <span class="dt">pch=</span><span class="dv">15</span>, <span class="dt">col=</span><span class="dv">4</span>)
<span class="kw">legend</span>(<span class="kw">par</span>(<span class="st">"usr"</span>)[<span class="dv">1</span>], <span class="kw">par</span>(<span class="st">"usr"</span>)[<span class="dv">4</span>], <span class="dt">legend=</span><span class="st">"points to buffer around"</span>, <span class="dt">pch=</span><span class="dv">15</span>, 
       <span class="dt">col=</span><span class="dv">4</span>, <span class="dt">cex=</span>.<span class="dv">6</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-31-1.png" width="480"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>))
<span class="kw">plot</span>(<span class="dt">x=</span>Kenai3.buf1, <span class="dt">main=</span><span class="st">"snap"</span>)
<span class="kw">points</span>(x, y, <span class="dt">pch=</span><span class="dv">15</span>, <span class="dt">col=</span><span class="dv">4</span>)
<span class="kw">plot</span>(<span class="dt">x=</span>Kenai3.buf2, <span class="dt">main=</span><span class="st">"snaproute"</span>)
<span class="kw">points</span>(x, y, <span class="dt">pch=</span><span class="dv">15</span>, <span class="dt">col=</span><span class="dv">4</span>)
<span class="kw">plot</span>(<span class="dt">x=</span>Kenai3.buf3, <span class="dt">main=</span><span class="st">"buffer, dist=5000"</span>)
<span class="kw">points</span>(x, y, <span class="dt">pch=</span><span class="dv">15</span>, <span class="dt">col=</span><span class="dv">4</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-32-1.png" width="720"></p>
<p>Automatically removing all segments not connected to the river network mouth can be done using <code><a href="../reference/removeunconnected.html">removeunconnected()</a></code>. This may be useful if extraneous lines are retained from an import from GIS. This function may take some time to process, and simplifying the network using <code><a href="../reference/dissolve.html">dissolve()</a></code> is recommended.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(Koyukuk2)
Koy_subset &lt;-<span class="st"> </span><span class="kw"><a href="../reference/trimriver.html">trimriver</a></span>(<span class="dt">trimto=</span><span class="kw">c</span>(<span class="dv">30</span>,<span class="dv">28</span>,<span class="dv">29</span>,<span class="dv">3</span>,<span class="dv">19</span>,<span class="dv">27</span>,<span class="dv">4</span>),<span class="dt">rivers=</span>Koyukuk2)
Koy_subset &lt;-<span class="st"> </span><span class="kw"><a href="../reference/setmouth.html">setmouth</a></span>(<span class="dt">seg=</span><span class="dv">1</span>,<span class="dt">vert=</span><span class="dv">427</span>,<span class="dt">rivers=</span>Koy_subset)

Koy_subset_trim &lt;-<span class="st"> </span><span class="kw"><a href="../reference/removeunconnected.html">removeunconnected</a></span>(Koy_subset)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw">plot</span>(<span class="dt">x=</span>Koy_subset, <span class="dt">main=</span><span class="st">"original"</span>)
<span class="kw">plot</span>(<span class="dt">x=</span>Koy_subset_trim, <span class="dt">main=</span><span class="st">"unconnected segments removed"</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-33-1.png" width="720"></p>
<p><a name="Issue%20the%20river%20network%20contains%20sequential%20runs%20of%20segments%20that%20do%20not%20otherwise%20branch"></a></p>
<p><strong>Issue: the river network contains sequential “runs” of segments that do not otherwise branch - a fix using <code><a href="../reference/dissolve.html">dissolve()</a></code></strong></p>
<p>Using an unnecessarily complex river network can greatly increase processing time. Runs of segments can be combined using <code><a href="../reference/dissolve.html">dissolve()</a></code>, which works much like a spatial dissolve within GIS.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(Kenai2)
Kenai2_sub &lt;-<span class="st"> </span><span class="kw"><a href="../reference/trimriver.html">trimriver</a></span>(<span class="dt">trimto=</span><span class="kw">c</span>(<span class="dv">26</span>,<span class="dv">157</span>,<span class="dv">141</span>,<span class="dv">69</span>,<span class="dv">3</span>,<span class="dv">160</span>,<span class="dv">2</span>,<span class="dv">35</span>,<span class="dv">102</span>,<span class="dv">18</span>,<span class="dv">64</span>,<span class="dv">86</span>,<span class="dv">49</span>,<span class="dv">103</span>,<span class="dv">61</span>,
                                 <span class="dv">43</span>,<span class="dv">183</span>,<span class="dv">72</span>,<span class="dv">47</span>,<span class="dv">176</span>), <span class="dt">rivers=</span>Kenai2)

Kenai2_sub_dissolve &lt;-<span class="st"> </span><span class="kw"><a href="../reference/dissolve.html">dissolve</a></span>(<span class="dt">rivers=</span>Kenai2_sub)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw">plot</span>(<span class="dt">x=</span>Kenai2_sub, <span class="dt">main=</span><span class="st">"original"</span>)
<span class="kw">plot</span>(<span class="dt">x=</span>Kenai2_sub_dissolve, <span class="dt">main=</span><span class="st">"dissolved"</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-34-1.png" width="720"></p>
<p><a name="Issue%20the%20river%20network%20segments%20do%20not%20break%20where%20they%20should"></a></p>
<p><strong>Issue: the river network segments do not break where they should - a fix using <code><a href="../reference/splitsegments.html">splitsegments()</a></code></strong></p>
<p>This issue is problematic, as it directly affects how connectivity is detected within the river network. Without appropriate connectivity, routes and distances cannot be calculated. To address this issue, <code><a href="../reference/splitsegments.html">splitsegments()</a></code> automatically breaks segments where another segment endpoint is detected.</p>
<p>In the example below, segments 7, 8, 13, and 16 need to be split in multiple places. Since connectedness is not detected for the associated tributaries, <code><a href="../reference/topologydots.html">topologydots()</a></code> shows the endpoints as red, or unconnected. In this case, calling <code><a href="../reference/splitsegments.html">splitsegments()</a></code> breaks the segments in the appropriate places, allowing for the network to be connected as it should be. It is worth noting that the user can specify which segments to split, with respect to which, which may aid in processing time and specificity.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(Koyukuk1)

Koyukuk1.split &lt;-<span class="st"> </span><span class="kw"><a href="../reference/splitsegments.html">splitsegments</a></span>(<span class="dt">rivers=</span>Koyukuk1)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw"><a href="../reference/topologydots.html">topologydots</a></span>(<span class="dt">rivers=</span>Koyukuk1, <span class="dt">main=</span><span class="st">"original"</span>)
<span class="kw"><a href="../reference/topologydots.html">topologydots</a></span>(<span class="dt">rivers=</span>Koyukuk1.split, <span class="dt">main=</span><span class="st">"split"</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-35-1.png" width="720"></p>
<p><a name="Issue%20segments%20that%20should%20connect%20do%20not"></a></p>
<p><strong>Issue: segments that should connect do not - a fix using <code><a href="../reference/connectsegs.html">connectsegs()</a></code></strong></p>
<p>Segments (or vectors of segments) can be manually “attached” at their endpoints or closest points using <code><a href="../reference/connectsegs.html">connectsegs()</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(Koyukuk0)

Koyukuk0.<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw"><a href="../reference/connectsegs.html">connectsegs</a></span>(<span class="dt">connect=</span><span class="dv">21</span>, <span class="dt">connectto=</span><span class="dv">20</span>, <span class="dt">rivers=</span>Koyukuk0)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw">plot</span>(Koyukuk0, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">1930500</span>,<span class="dv">1931500</span>), <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">194900</span>,<span class="dv">195100</span>), <span class="dt">main=</span><span class="st">"original"</span>)
<span class="kw"><a href="../reference/topologydots.html">topologydots</a></span>(Koyukuk0, <span class="dt">add=</span><span class="ot">TRUE</span>)

<span class="kw">plot</span>(Koyukuk0.<span class="dv">1</span>,<span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">1930500</span>,<span class="dv">1931500</span>), <span class="dt">xlim=</span><span class="kw">c</span>(<span class="dv">194900</span>,<span class="dv">195100</span>), <span class="dt">main=</span><span class="st">"connected"</span>)
<span class="kw"><a href="../reference/topologydots.html">topologydots</a></span>(Koyukuk0.<span class="dv">1</span>, <span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-36-1.png" width="720"></p>
<p><a name="Issue%20the%20river%20network%20contains%20segments%20that%20are%20smaller%20than%20the%20connectivity%20tolerance"></a></p>
<p><strong>Issue: the river network contains segments that are smaller than the connectivity tolerance - a fix using <code><a href="../reference/removemicrosegs.html">removemicrosegs()</a></code></strong></p>
<p>This is an issue that may be difficult to recognize, and may cause mysterious problems with network topology, sometimes preventing route calculation. These “microsegments” can be removed using <code><a href="../reference/removemicrosegs.html">removemicrosegs()</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(abstreams0)
abstreams2 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/removemicrosegs.html">removemicrosegs</a></span>(abstreams0)</code></pre></div>
<p><a name="Issue%20A%20long%20straight-line%20section%20of%20the%20river%20network%20does%20not%20contain%20vertices%20between%20endpoints"></a></p>
<p><strong>Issue: A long straight-line section of the river network does not contain vertices between endpoints - a fix using <code><a href="../reference/addverts.html">addverts()</a></code></strong></p>
<p>In some cases, such as when a river network contains a lake, the shapefile will contain long straight-line sections, with vertices retained only for the beginning and end. If point data exist in these regions, when they are converted to river locations, they will be snapped to the nearest vertex - in this case, one of the endpoints of the straight stretch. Since it is likely that a greater degree of precision is desired in distance calculations, <code><a href="../reference/addverts.html">addverts()</a></code> provides a method of inserting additional vertices, wherever the river network contains vertices that are spaced at a greater distance than a specified threshold.</p>
<p>The example below first shows how the Skilak Lake section of the Kenai River network was originally read from a shapefile, with the vertices of segment 74 overlayed. The second plot shows the same section with the vertices of segment 74 overlayed, after adding vertices every 200 meters to the full river network.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(Kenai3)
Kenai3split &lt;-<span class="st"> </span><span class="kw"><a href="../reference/addverts.html">addverts</a></span>(Kenai3, <span class="dt">mindist=</span><span class="dv">200</span>)

<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw"><a href="../reference/zoomtoseg.html">zoomtoseg</a></span>(<span class="dt">seg=</span><span class="kw">c</span>(<span class="dv">47</span>,<span class="dv">74</span>,<span class="dv">78</span>), <span class="dt">rivers=</span>Kenai3, <span class="dt">main=</span><span class="st">"segment 74 vertices"</span>)
<span class="kw">points</span>(Kenai3<span class="op">$</span>lines[[<span class="dv">74</span>]]) 

<span class="kw"><a href="../reference/zoomtoseg.html">zoomtoseg</a></span>(<span class="dt">seg=</span><span class="kw">c</span>(<span class="dv">47</span>,<span class="dv">74</span>,<span class="dv">78</span>), <span class="dt">rivers=</span>Kenai3split, <span class="dt">main=</span><span class="st">"adding points every 200m"</span>)
<span class="kw">points</span>(Kenai3split<span class="op">$</span>lines[[<span class="dv">74</span>]])  </code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-38-1.png" width="720"></p>
<p><a name="Dealing%20with%20braided%20channels"></a></p>
</div>
<div id="dealing-with-braided-channels" class="section level2">
<h2 class="hasAnchor">
<a href="#dealing-with-braided-channels" class="anchor"></a>Dealing with braided channels</h2>
<p>Most of the utility of the ‘riverdist’ package was designed assuming a truly dendritic river network, in which there is no braiding of channels and only one path exists between one river location and another. If this is not the case and a braided network is used, the user is <strong>strongly cautioned</strong> that the distances reported may be inaccurate. In the event of braiding, the shortest route between two locations is returned, but the possibility exists that this may not be the route desired.</p>
<p><a href="#Checking%20for%20braiding">Checking for braiding</a></p>
<p><a href="#Investigating%20multiple%20routes">Investigating multiple routes</a></p>
<p><a name="Checking%20for%20braiding"></a></p>
<p><strong>Checking for braiding using <code><a href="../reference/checkbraided.html">checkbraided()</a></code></strong></p>
<p>Braiding can be checked for in a river network as a whole using <code><a href="../reference/checkbraided.html">checkbraided()</a></code>, which can take a while to run on a large or complex network. In the example below, no braiding exists in the Gulkana River network, and severe braiding exists in the Killey River West channel network.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(Gulk, KilleyW)
<span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw">plot</span>(<span class="dt">x=</span>Gulk, <span class="dt">main=</span><span class="st">"Gulkana River"</span>)
<span class="kw">plot</span>(<span class="dt">x=</span>KilleyW, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">1164500</span>, <span class="dv">1168500</span>), <span class="dt">main=</span><span class="st">"Killey River West"</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-39-1.png" width="720"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/checkbraided.html">checkbraided</a></span>(<span class="dt">rivers=</span>Gulk, <span class="dt">progress=</span><span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## 
##  No braiding detected in river network.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/checkbraided.html">checkbraided</a></span>(<span class="dt">rivers=</span>KilleyW, <span class="dt">progress=</span><span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## 
##  Braiding detected in river network.  Distance measurements may be inaccurate.</code></pre>
<p>Braiding can also be checked for specific routes. In the example below, braiding does not exist between segments 1 and 7, but does exist between segments 1 and 5.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Kenai3.subset &lt;-<span class="st"> </span><span class="kw"><a href="../reference/trimriver.html">trimriver</a></span>(<span class="dt">trimto=</span><span class="kw">c</span>(<span class="dv">22</span>,<span class="dv">2</span>,<span class="dv">70</span>,<span class="dv">30</span>,<span class="dv">15</span>,<span class="dv">98</span>,<span class="dv">96</span>,<span class="dv">89</span>,<span class="dv">52</span>,<span class="dv">3</span>), <span class="dt">rivers=</span>Kenai3)</code></pre></div>
<pre><code>## Note: any point data already using the input river network must be re-transformed to river coordinates using xy2segvert() or ptshp2segvert().</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="dt">x=</span>Kenai3.subset)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-40-1.png" width="480"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/checkbraided.html">checkbraided</a></span>(<span class="dt">startseg=</span><span class="dv">1</span>, <span class="dt">endseg=</span><span class="dv">7</span>, <span class="dt">rivers=</span>Kenai3.subset)</code></pre></div>
<pre><code>## No braiding detected between segments.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/checkbraided.html">checkbraided</a></span>(<span class="dt">startseg=</span><span class="dv">1</span>, <span class="dt">endseg=</span><span class="dv">5</span>, <span class="dt">rivers=</span>Kenai3.subset)</code></pre></div>
<pre><code>## Braiding detected between segments.  Distance measurements may be inaccurate.</code></pre>
<p><a name="Investigating%20multiple%20routes"></a></p>
<p><strong>Investigating multiple routes using <code><a href="../reference/riverdistancelist.html">riverdistancelist()</a></code></strong></p>
<p>If the user wishes to explore the possibility of multiple routes beween two locations, <code><a href="../reference/routelist.html">routelist()</a></code> detects a list of routes from one segment to another, which is applied by function <code><a href="../reference/riverdistancelist.html">riverdistancelist()</a></code> to calculate the distance along the routes that were detected. This was by means of randomization in a previous version, but now uses an algorithm that returns a complete list of possible routes. The <code><a href="../reference/riverdistancelist.html">riverdistancelist()</a></code> function, shown below, returns a list of all routes detected by ascending distance, and the corresponding distances.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Killey.dists &lt;-<span class="st"> </span><span class="kw"><a href="../reference/riverdistancelist.html">riverdistancelist</a></span>(<span class="dt">startseg=</span><span class="dv">1</span>,<span class="dt">endseg=</span><span class="dv">16</span>,<span class="dt">startvert=</span><span class="dv">25</span>,<span class="dt">endvert=</span><span class="dv">25</span>,
   <span class="dt">rivers=</span>KilleyW,<span class="dt">reps=</span><span class="dv">1000</span>)
Killey.dists  <span class="co"># 18 routes are detected.</span></code></pre></div>
<pre><code>## $routes
## $routes[[1]]
## [1]  1  2  4 15 16
## 
## $routes[[2]]
##  [1]  1  2  4  5  6  8  9 11 12 14 16
## 
## $routes[[3]]
## [1]  1  3  4 15 16
## 
## $routes[[4]]
##  [1]  1  3  4  5  6  8  9 11 12 14 16
## 
## $routes[[5]]
##  [1]  1  2  4  5  7  8  9 11 12 14 16
## 
## $routes[[6]]
##  [1]  1  2  4  5  6  8 10 11 12 14 16
## 
## $routes[[7]]
##  [1]  1  3  4  5  7  8  9 11 12 14 16
## 
## $routes[[8]]
##  [1]  1  3  4  5  6  8 10 11 12 14 16
## 
## $routes[[9]]
##  [1]  1  2  4  5  6  8  9 11 13 14 16
## 
## $routes[[10]]
##  [1]  1  2  4  5  7  8 10 11 12 14 16
## 
## $routes[[11]]
##  [1]  1  3  4  5  6  8  9 11 13 14 16
## 
## $routes[[12]]
##  [1]  1  3  4  5  7  8 10 11 12 14 16
## 
## $routes[[13]]
##  [1]  1  2  4  5  7  8  9 11 13 14 16
## 
## $routes[[14]]
##  [1]  1  2  4  5  6  8 10 11 13 14 16
## 
## $routes[[15]]
##  [1]  1  3  4  5  7  8  9 11 13 14 16
## 
## $routes[[16]]
##  [1]  1  3  4  5  6  8 10 11 13 14 16
## 
## $routes[[17]]
##  [1]  1  2  4  5  7  8 10 11 13 14 16
## 
## $routes[[18]]
##  [1]  1  3  4  5  7  8 10 11 13 14 16
## 
## 
## $distances
##  [1] 6044.006 6068.785 6147.616 6172.396 6230.349 6272.589 6333.960
##  [8] 6376.199 6386.100 6434.153 6489.710 6537.763 6547.664 6589.903
## [15] 6651.274 6693.514 6751.468 6855.078</code></pre>
<p>The shortest and longest routes detected are mapped below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))
<span class="kw">plot</span>(<span class="dt">x=</span>KilleyW, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">1164500</span>, <span class="dv">1168500</span>), <span class="dt">main=</span><span class="st">"shortest route"</span>)
<span class="kw"><a href="../reference/riverdistance.html">riverdistance</a></span>(<span class="dt">startvert=</span><span class="dv">25</span>, <span class="dt">endvert=</span><span class="dv">25</span>, <span class="dt">path=</span>Killey.dists<span class="op">$</span>routes[[<span class="dv">1</span>]], 
              <span class="dt">rivers=</span>KilleyW, <span class="dt">map=</span><span class="ot">TRUE</span>, <span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre></div>
<pre><code>## [1] 6044.006</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(KilleyW, <span class="dt">ylim=</span><span class="kw">c</span>(<span class="dv">1164500</span>, <span class="dv">1168500</span>), <span class="dt">main=</span><span class="st">"longest route"</span>)
<span class="kw"><a href="../reference/riverdistance.html">riverdistance</a></span>(<span class="dt">startvert=</span><span class="dv">25</span>, <span class="dt">endvert=</span><span class="dv">25</span>, <span class="dt">path=</span>Killey.dists<span class="op">$</span>routes[[<span class="dv">18</span>]], 
              <span class="dt">rivers=</span>KilleyW, <span class="dt">map=</span><span class="ot">TRUE</span>, <span class="dt">add=</span><span class="ot">TRUE</span>)</code></pre></div>
<p><img src="riverdist_vignette_files/figure-html/unnamed-chunk-42-1.png" width="720"></p>
<pre><code>## [1] 6855.078</code></pre>
<p>It is worth noting that the default functions for route and distance calculation do return the shortest route, in the presence of multiple possible routes. The default-calculated route is shown below, and is the same as the shortest route determined by <code><a href="../reference/riverdistancelist.html">riverdistancelist()</a></code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/detectroute.html">detectroute</a></span>(<span class="dt">start=</span><span class="dv">1</span>, <span class="dt">end=</span><span class="dv">16</span>, <span class="dt">rivers=</span>KilleyW)</code></pre></div>
<pre><code>## [1]  1  2  4 15 16</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Killey.dists<span class="op">$</span>routes[[<span class="dv">1</span>]]  <span class="co">#calculated above</span></code></pre></div>
<pre><code>## [1]  1  2  4 15 16</code></pre>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#package-overview">Package overview</a></li>
      <li><a href="#typical-workflow-with-riverdist">Typical workflow with ‘riverdist’</a></li>
      <li><a href="#limitations-notes-and-caveats">Limitations, notes, and caveats</a></li>
      <li><a href="#importing-and-displaying-river-network-data">Importing and displaying river network data</a></li>
      <li><a href="#basic-distance-calculation-in-a-non-messy-river-network">Basic distance calculation in a non-messy river network</a></li>
      <li><a href="#incorporating-flow-direction">Incorporating flow direction</a></li>
      <li><a href="#allowing-different-route-detection-algorithms-a-possible-time-saver">Allowing different route-detection algorithms: a possible time-saver</a></li>
      <li><a href="#beyond-individuals-summarizing-or-plotting-at-the-dataset-level">Beyond individuals: summarizing or plotting at the dataset level</a></li>
      <li><a href="#editing-a-river-network-object-or-fixing-a-messy-one">Editing a river network object, or fixing a messy one</a></li>
      <li><a href="#dealing-with-braided-channels">Dealing with braided channels</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Matt Tyers.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
